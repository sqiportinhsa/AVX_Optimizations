# Оптимизация альфа-блендинга при помощи AVX/AVX2

## Альфа-блендинг

![result](images/output.bmp)

Альфа-блендинг - комбинирование изображения с фоном с целью создания эффекта частичной прозрачности. Суть метода заключается в том, что всем пикселям переднего изображения помимо значений красного, зеленого и синего цветов присваивается значение прозрачности, называемое альфа-каналом. При объединении изображения с непрозрачным фоном вычисление значения цвета пикселя происходит по формуле:

$$X_{res} = X_{front} * A_{front} + X_{back} * (1 - A_{front}),$$

где $X_{front}, X_{back}, X_{res}$ - компоненты цветов изображения, фона и результата соответственно.

В данной задаче мы реализуем альфа-блендинг при помощи формулы выше, после чего оптимизируем его при помощи AVX и AVX2 интринсиков и сравним результаты.

## Общая информация

Характеристики ноутбука:

| Характеристики |                    |
|----------------|--------------------|
| OS             | Linux Mint 21      |
| CPU            | AMD Ryzen 7 5800H  |
| Compiler       | gcc 11.3.0         |

Флаги для сборки:
`-O3 -mavx -mavx2`

Измерения производятся при полной зарядке ноутбука с питанием от сети, параллельно никаких действий на ноутбуке не выполнется.

### Измерение времени

Измерение времени производится для функции вычисления значений пикселей результирующего изображения. Функция имеет прототип `void (Image *front, Image *background, uint32_t *dest)` во всех реализациях.

Измерение времени производится для функции вычисления количества итераций, необходимого точкам для того, чтобы их последовательности вышли за пределы заданной области. Функция имеет прототип void (u_int32_t *counters) и при помощи двойного цикла записывает в полученный массив значения для всех точек экрана.

Вычисление значений массива производится несколько раз вподряд путем повторного вызова функции вычисления, измеряется суммарное время для всех вызовов. Значение числа вызовов определяется константой `COUNT_TIMES`. Так же для повышения точности время усредняется по нескольким измерениям, вычисляется среднеквадратичное значение. Отрисовка производится перед началом измерений по однократному вызову функции для проверки корректности её работы, после чего происходит снова после окончания вычислений

### Константы для вычислений
Константы определены в заголовочном файле `common.h`.

| тип          | имя             | значение        | смысл |
|--------------|-----------------|-----------------|-------|
| const int    | COUNT_TIMES     | $10^5$ и $10^6$ | Количество повторений вычисления значений массива для скалярной и векторной реализаций соответственно.
| const int    | REPEAT_BENCH    | 100             | Количество повторения измерений для усреднения.
| const int    | XSHIFT          | 400             | Глобальная константа для конкретных кота и рыбы, задающая смещение рыбы по горизонтали относительно левого верхнего угла в пикселях
| const int    | YSHIFT          | 0               | Глобальная константа для конкретных кота и рыбы, задающая смещение рыбы по вертикали относительно левого верхнего угла в пикселях

### Особенности оптимизаций и измерения

Будем считать, что эта часть работы выполняется после вычисления множества Мандельброта, и в ней можно учитывать результаты, полученные там. В частности будем считать, что:
* Вызовы функции затрачивают незначительную часть времени по сравнению с временем нахождения внутри функции.

## Скалярная реализация

Суть реализации - вычисление значений BGRA для каждого пикселя напрямую в двойном цикле. При этом предварительно (вне функции вычисления) при помощи `memcpy` в массив пикселей нового изображения копируется фон. После этого в функции вычисления находятся значения для той области, куда нужно поместить верхнее изображение, и перезаписываются в массиве результата. Фрагмент кода тела цикла, реализующий вычисление:

```c++
Pixel back_pixel  = {};
Pixel front_pixel = {};

back_pixel.val  = back_src[(y+yshift) * back_width + x + xshift];
front_pixel.val = front_src[y*front_width + x];

uint8_t alpha = front_pixel.rgba.a;
uint8_t not_alpha = 255 - alpha;

Pixel pixel;
pixel.rgba.a = 255;
pixel.rgba.r = (back_pixel.rgba.r * not_alpha + front_pixel.rgba.r * alpha) >> 8;
pixel.rgba.g = (back_pixel.rgba.g * not_alpha + front_pixel.rgba.g * alpha) >> 8; 
pixel.rgba.b = (back_pixel.rgba.b * not_alpha + front_pixel.rgba.b * alpha) >> 8;

dest[(y+yshift) * back_width + x + xshift] = (uint32_t) pixel.val;
```

При этом `Pixel` представляет из себя `union`, интерпретируемый как структура из четырех `uint8_t` или одно число `uint32_t`. 

## Оптимизация при помощи AVX/AVX2 intrinsics

Для оптимизации будем вычислять одновременно значения для 8 точек. Для этого будем загружать из массивов переднего и заднего изображений по $256$ бит, и производить векторные операции сразу с $32$ значениями типа `uint8_t`, отвечающими за цвета и альфа-каналы восьми соседних точек. Для этого мы создаем переменные типа `__m256i` для значений прозрачности, соответствующих фону и картинке:
```c++
__m256i alpha = _mm256_shuffle_epi8(front_pixels, ALPHA_MASK);
// front_pixels = [a8 r8 g8 b8 | ... | a0 r0 g0 b0]
//                  |                   |
//                  |--------.          |--------.
//                  |  |  |  |          |  |  |  |
// alpha =        [a8 a8 a8 a8 | ... | a0 a0 a0 a0]
front_pixels = _mm256_mulhi_epi8_own(front_pixels, alpha); // X_front * A_front

alpha = _mm256_sub_epi8(const255, alpha);
// front_pixels = [a8      a8      a8      a8     | ... | a0      a0      a0      a0    ]
//                  \       \       \       \              \       \       \       \
// alpha =        [255-a8  255-a8  255-a8  255-a8 | ... | 255-a0  255-a0  255-a0  255-a0]
back_pixels = _mm256_mulhi_epi8_own(back_pixels, alpha); // X_back * (1 - A_front)
```

К сожалению, функция `_mm256_mulhi_epi8` не реализована в `AVX` и `AVX2`, поэтому была написана при помощи `_mm256_mulhi_epi16` и разбиения переменной на две части при помощи `shuffle`:

```c++
__m256i low_a  = _mm256_shuffle_epi8(a, SPLIT_LOW_MASK);
__m256i low_b  = _mm256_shuffle_epi8(b, SPLIT_LOW_MASK);
__m256i high_a = _mm256_shuffle_epi8(a, SPLIT_HIGH_MASK);
__m256i high_b = _mm256_shuffle_epi8(b, SPLIT_HIGH_MASK);   

// a: [a31-a24 | a23-a16 | a15-a8 | a7-a0]
// 
// a_high:  [ a31 0 a30 0 ... 0 a24 0 | a15 0 a14 0 ... 0 a8 0]
// a_low:   [ a23 0 a22 0 ... 0 a16 0 | a7  0 a6  0 ... 0 a0 0]

__m256i mul_low  = _mm256_mullo_epi16(low_a,  low_b);
__m256i mul_high = _mm256_mullo_epi16(high_a, high_b);

// high: [ (a31 * b31)_hi | (a31 * b31)_lo | (a30 * b30)_hi | (a30 * b30)_lo | ... ]    
// low:  [ (a23 * b23)_hi | (a23 * b23)_lo | (a22 * b22)_hi | (a22 * b22)_lo | ... ] 

mul_low  = _mm256_shuffle_epi8(mul_low,  MOVE_LOW_MASK);
mul_high = _mm256_shuffle_epi8(mul_high, MOVE_HIGH_MASK);

// high: [ ab31_hi | ... | ab24_hi |  ----   | ... |   ----  | ab15_hi | ... ]
// low:  [  ----   | ... |  ----   | ab23_hi | ... | ab16_hi |  ----   | ... ]

__m256i res = _mm256_add_epi8(mul_high, mul_low);

// res: [ ab31_hi - ab0_hi ]
```

## Предположение о работе оптимизации

Параллельно мы вычисляем значения для 8 соседних точек. При этом, в отличие от предыдущей части работы, здесь нет цикла, избыточно повторяющегося для части точек, что позволяет сделать предположение о приближении значения ускорения векторной версии относительно скалярной в 8 раз.

## Результаты измерения времени

Таблица результатов, данные обработаны по следующим правилам:
* погрешность имеет 2 значащие цифры в случае, если первая из них - единица
* иначе погрешность имеет одну значащую цифру
* время округляется до той же точности, что и погрешность
* округление времени и погрешности производится по правилам округления

### Корректность проведения измерений

Предположение: мы можем сравнивать значения для программ, запущенных друг за другом.

Способ проверки: будем запускать программы по очереди, и сравнивать друг с другом значения, полученные для одной программы. Если они отличаются незначительно, можно считать, что в течение времени их исполнения и времени между запусками состояние компьютера было постоянным. Тогда сравнение результатов работы программы с результатом, полученным между двумя запусками.

Измерения:

Скалярная реализация:

| номер запуска программы | время на $10^5$ повторений, сек | погрешность, сек |
|-------------------------|---------------------------------|------------------|
| 1                       | 247                             | 9                |
| 2                       | 245                             | 12               |
| 3                       | 246                             | 11               |

Векторная реализация:

| номер запуска программы | время на $10^6$ повторений, сек | погрешность, сек |
|-------------------------|---------------------------------|------------------|
| 1                       | 258                             | 5                |
| 2                       | 237                             | 9                |
| 3                       | 249                             | 6                | 

Мы видим, что с точностью до погрешности полученные значения различных запусков совпадают, что значит, что сравнение корректно. Более того, погрешность составляет не более 5 процентов, что значит, что значения пригодны для сравения. Увеличим погрешность до $1/2$ максимальной разницы мажду различными измерениями для векторной реализации, чтобы быть уверенными, что погрешность покрывает изменения в состоянии компьютера.

### Вычисление и сравнение коэффициентов

Будем использовать усредненные значения трех измерений. Получаем следующие результаты:

| реализация | время на `COUNT_TIMES` запусков, сек | время на один запуск, ms | погрешность времени на один запуск, ms |
|------------|--------------------------------------|--------------------------|----------------------------------------|
| скалярная  | 246                                  | 24.6                     | 0.9                                    |
| векторная  | 258                                  | 2.5                      | 0.1                                    |

Соотношение времен: $9.5 \pm 0.3$.

## Анализ полученных результатов

Почему так вышло, что полученное ускорение в $10.3$ раза превысило ожидаемое ускорение в $8$ раз за счет использования SIMD оптимизаций? Посмотрим, что происходит с кодом при оптимизациях компилятора:


```assembly
_mm256_mulhi_epi8_own(long long __vector(4), long long __vector(4)):
vpshufb ymm2, ymm0, YMMWORD PTR SPLIT_LOW_MASK[rip]  ;     __m256i low_a  = _mm256_shuffle_epi8(a, SPLIT_LOW_MASK);
vpshufb ymm3, ymm1, YMMWORD PTR SPLIT_LOW_MASK[rip]  ;     __m256i low_b  = _mm256_shuffle_epi8(b, SPLIT_LOW_MASK);
vpshufb ymm0, ymm0, YMMWORD PTR SPLIT_HIGH_MASK[rip] ;     __m256i high_a = _mm256_shuffle_epi8(a, SPLIT_HIGH_MASK);
vpshufb ymm1, ymm1, YMMWORD PTR SPLIT_HIGH_MASK[rip] ;     __m256i high_b = _mm256_shuffle_epi8(b, SPLIT_HIGH_MASK); 

vpmullw ymm2, ymm2, ymm3                             ;     __m256i mul_low  = _mm256_mullo_epi16(low_a,  low_b);
vpmullw ymm1, ymm0, ymm1                             ;     __m256i mul_high = _mm256_mullo_epi16(high_a, high_b);

vpshufb ymm2, ymm2, YMMWORD PTR MOVE_LOW_MASK[rip]   ;     mul_low  = _mm256_shuffle_epi8(mul_low,  MOVE_LOW_MASK);
vpshufb ymm1, ymm1, YMMWORD PTR MOVE_HIGH_MASK[rip]  ;     mul_high = _mm256_shuffle_epi8(mul_high, MOVE_HIGH_MASK);
vpaddb  ymm0, ymm2, ymm1                             ;     __m256i res = _mm256_add_epi8(mul_high, mul_low);

ret
```

Функция умножения никак не оптимизируется. Посмотрим на тело цикла функции вычисления целиком:

![vector_blend](godbolt/vectorblend.png)

Как мы видим, здесь никаких дополнительных оптимизаций тоже не произошло, команды в ассемблерном коде совпадают с командами в исходном коде с точностью до перестановок. Получается, проблема в скалярной реализации. Действительно, её ассемблированный код для пяти строк вычисления значений пикселей выглядит так:

![scalar_blend](godbolt/scalarblend.png)

```c++
uint8_t not_alpha = 255 - alpha;
pixel.rgba.a = 255;
pixel.rgba.r = (back_pixel.rgba.r * not_alpha + front_pixel.rgba.r * alpha) >> 8;
pixel.rgba.g = (back_pixel.rgba.g * not_alpha + front_pixel.rgba.g * alpha) >> 8; 
pixel.rgba.b = (back_pixel.rgba.b * not_alpha + front_pixel.rgba.b * alpha) >> 8;
```
Количество команд для вычисления цвета одной точки в скалярном варианте превосходит количество команд, необходимое для вычисления цветов восьми точек в векторном, в полтора раза (32 для скалярного против 21 для векторного). Таким образом применение AVX и AVX2 оптимизации дает ожидаемое ускорение тела цикла примерно в 12 раз. Меньшее значение получается за счет других операций, использующихся и там и там - вычисление позиции на экране, сохранение параметров картинок в виде переменных для минимизации работы с памятью. Они применяются в равной мере в обеих реализациях, количество использований не сокращается, а значит уменьшается коэффициент ускорения.

## Замечание про оптимизации компиляторов

Оптытным путем было выяснено, что компилятор `clang` на уровнях оптимизации `-O3` и `-Ofast` способен векторизовать скалярную реализацию при помощи SSE или AVX (второе происходит в случае наличия флага -mavx).

https://godbolt.org/z/eqn85Tqj3

![clang_opt](godbolt/clang.png)

Автор восхищается возможностями современных компиляторов и изящностью сгенерированного кода. Для сравнения приведен скриншот ассемблированного кода автора:

![author_opt](godbolt/author.png)

Для сравнения скорости работы векторизации автором и компилятором обе реализации были скомпилированы при помощи clang, измерения дали следующие результаты:

| кол-во повторений    | время, сек    | погрешность, сек    |
|----------------------|---------------|---------------------|
| скалярная реализация | 26.4          | 0.8                 |
| векторная реализация | 22.2          | 0.2                 |

С учетом погрешности векторизованный вручную и скомпилированный при помощи `clang` результат выигрывает у векторизоавнного компилятором в $1.19 \pm 0.05$ раз.